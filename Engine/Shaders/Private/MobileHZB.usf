#include "Common.ush"
#include "ReductionCommon.ush"

float4 DispatchThreadIdToBufferUV;
float4 HZBInvDeviceZToWorldZTransform;
float2 InvSize;
float2 InputViewportMaxBound;

Texture2D ParentTextureMip;
SamplerState ParentTextureMipSampler;

#if PIXELSHADER
void HZBBuildPS
(
    float4 SvPosition : SV_POSITION, 
    out float4 OutColor : SV_Target0
)
{
#if FDimSceneDepth
	float2 BufferUV = SvPosition.xy * DispatchThreadIdToBufferUV.xy + DispatchThreadIdToBufferUV.zw;
    float2 UV = min(BufferUV + float2(-0.25f, -0.25f) * InvSize, InputViewportMaxBound - InvSize);
    float4 SceneDepth = ParentTextureMip.GatherAlpha(ParentTextureMipSampler, UV, 0);
	float FurthestSceneDepth = max(max(SceneDepth.x, SceneDepth.y), max(SceneDepth.z, SceneDepth.w));
	float FurthestDeviceZ = 1.f / ((FurthestSceneDepth + HZBInvDeviceZToWorldZTransform[3]) * HZBInvDeviceZToWorldZTransform[2]);
#else
	
	float4 DeviceZ;
	const uint2 PixelCoord = floor(SvPosition.xy) * 2;
    DeviceZ.x = ParentTextureMip.Load(int3(PixelCoord + int2(0, 0), 0));
    DeviceZ.y = ParentTextureMip.Load(int3(PixelCoord + int2(0, 1), 0));
    DeviceZ.z = ParentTextureMip.Load(int3(PixelCoord + int2(1, 0), 0));
    DeviceZ.w = ParentTextureMip.Load(int3(PixelCoord + int2(1, 1), 0));
	float FurthestDeviceZ = min(min(DeviceZ.x, DeviceZ.y), min(DeviceZ.z, DeviceZ.w));
	  
	//float4 DeviceZ = ParentTextureMip.GatherRed(ParentTextureMipSampler, UV, 0);
	//float FurthestDeviceZ = min(min(DeviceZ.x, DeviceZ.y), min(DeviceZ.z, DeviceZ.w));
#endif
	
    OutColor = FurthestDeviceZ;
}

#elif 1

#define MAX_MIP_BATCH_SIZE 4
#define GROUP_TILE_SIZE 8


RWTexture2D<float> FurthestHZBOutput;

//RWTexture2D<float> FurthestHZBOutput_0;
//RWTexture2D<float> FurthestHZBOutput_1;
//RWTexture2D<float> FurthestHZBOutput_2;
//RWTexture2D<float> FurthestHZBOutput_3;

groupshared float SharedFurthestDeviceZ[GROUP_TILE_SIZE * GROUP_TILE_SIZE];
//groupshared float SharedClosestDeviceZ[GROUP_TILE_SIZE * GROUP_TILE_SIZE];

void OutputMipLevel(uint MipLevel, uint2 OutputPixelPos, float FurthestDeviceZ)
{
#if DIM_MIP_LEVEL_COUNT >= 2
	if (MipLevel == 1)
	{	
		FurthestHZBOutput_1[OutputPixelPos] = FurthestDeviceZ;
	}
#endif
#if DIM_MIP_LEVEL_COUNT >= 3
	else if (MipLevel == 2)
	{
		FurthestHZBOutput_2[OutputPixelPos] = FurthestDeviceZ;
	}
#endif
#if DIM_MIP_LEVEL_COUNT >= 4
	else if (MipLevel == 3)
	{
		FurthestHZBOutput_3[OutputPixelPos] = FurthestDeviceZ;
	}		
#endif
}

[numthreads(GROUP_TILE_SIZE, GROUP_TILE_SIZE, 1)]
void HZBBuildCS(
	uint2 GroupId : SV_GroupID,
	uint GroupThreadIndex : SV_GroupIndex)
{
#if DIM_MIP_LEVEL_COUNT == 1
		uint2 GroupThreadId = uint2(GroupThreadIndex % GROUP_TILE_SIZE, GroupThreadIndex / GROUP_TILE_SIZE);
#else
	uint2 GroupThreadId = InitialTilePixelPositionForReduction2x2(MAX_MIP_BATCH_SIZE - 1, GroupThreadIndex);
#endif

	uint2 DispatchThreadId = GROUP_TILE_SIZE * GroupId + GroupThreadId;

	float2 BufferUV = (DispatchThreadId + 0.5) * DispatchThreadIdToBufferUV.xy + DispatchThreadIdToBufferUV.zw;
	float2 UV = min(BufferUV + float2(-0.25f, -0.25f) * InvSize, InputViewportMaxBound - InvSize);
	
	float4 DeviceZ = ParentTextureMip.GatherRed(ParentTextureMipSampler, UV, 0);

	float FurthestDeviceZ = min(min(DeviceZ.x, DeviceZ.y), min(DeviceZ.z, DeviceZ.w));
	
	uint2 OutputPixelPos = DispatchThreadId;
	
	FurthestHZBOutput[OutputPixelPos] = FurthestDeviceZ;
	
	#if DIM_MIP_LEVEL_COUNT == 1
	{
		// NOP
	}
	#else
	{
		SharedFurthestDeviceZ[GroupThreadIndex] = FurthestDeviceZ;
	
		UNROLL
		for (uint MipLevel = 1; MipLevel < DIM_MIP_LEVEL_COUNT; MipLevel++)
		{
			const uint TileSize = GROUP_TILE_SIZE / (1 << MipLevel);
			const uint ReduceBankSize = TileSize * TileSize;
			
			// LDS has been written before.
			if (MipLevel == 1)
				GroupMemoryBarrierWithGroupSync();

			BRANCH

			if (GroupThreadIndex < ReduceBankSize)
			{
				float4 ParentFurthestDeviceZ;
				ParentFurthestDeviceZ[0] = FurthestDeviceZ;

				UNROLL

				for (uint i = 1; i < 4; i++)
				{
					uint LDSIndex = GroupThreadIndex + i * ReduceBankSize;
					ParentFurthestDeviceZ[i] = SharedFurthestDeviceZ[LDSIndex];
				}
				
				FurthestDeviceZ = min(min(ParentFurthestDeviceZ.x, ParentFurthestDeviceZ.y), min(ParentFurthestDeviceZ.z, ParentFurthestDeviceZ.w));

				OutputPixelPos = OutputPixelPos >> 1;
				OutputMipLevel(MipLevel, OutputPixelPos, FurthestDeviceZ);
				
				SharedFurthestDeviceZ[GroupThreadIndex] = FurthestDeviceZ;
			}
		}
	}
#endif
}

#endif