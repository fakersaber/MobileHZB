#pragma once

#include "Common.ush"

// Rect is inclusive [Min.xy, Max.xy]
int MipLevelForRect(int4 RectPixels, int DesiredFootprintPixels)
{
    const int MaxPixelOffset = DesiredFootprintPixels - 1;
    const int MipOffset = (int) log2((float) DesiredFootprintPixels) - 1;

	// Calculate lowest mip level that allows us to cover footprint of the desired size in pixels.
	// Start by calculating separate x and y mip level requirements.
	// 2 pixels of mip k cover 2^(k+1) pixels of mip 0. To cover at least n pixels of mip 0 by two pixels of mip k we need k to be at least k = ceil( log2( n ) ) - 1.
	// For integer n>1: ceil( log2( n ) ) = floor( log2( n - 1 ) ) + 1.
	// So k = floor( log2( n - 1 )
	// For integer n>1: floor( log2( n ) ) = firstbithigh( n )
	// So k = firstbithigh( n - 1 )
	// As RectPixels min/max are both inclusive their difference is one less than number of pixels (n - 1), so applying firstbithigh to this difference gives the minimum required mip.
	// NOTE: firstbithigh is a FULL rate instruction on GCN while log2 is QUARTER rate instruction.
    
    //GLSL findMSB or findLSB
    int2 MipLevelXY = firstbithigh(RectPixels.zw - RectPixels.xy);
    
	// Mip level needs to be big enough to cover both x and y requirements. Go one extra level down for 4x4 sampling.
	// firstbithigh(0) = -1, so clamping with 0 here also handles the n=1 case where mip 0 footprint is just 1 pixel wide/tall.
    int MipLevel = max(max(MipLevelXY.x, MipLevelXY.y) - MipOffset, 0);

	// MipLevel now contains the minimum MipLevel that can cover a number of pixels equal to the size of the rectangle footprint, but the HZB footprint alignments are quantized to powers of two.
	// The quantization can translate down the start of the represented range by up to 2^k-1 pixels, which can decrease the number of usable pixels down to 2^(k+1) - 2^k-1.
	// Depending on the alignment of the rectangle this might require us to pick one level higher to cover all rectangle footprint pixels.
	// Note that testing one level higher is always enough as this guarantees 2^(k+2) - 2^k usable pixels after alignment, which is more than the 2^(k+1) required pixels.
	
	// Transform coordinates down to coordinates of selected mip level and if they are not within reach increase level by one.
    // 貌似当 End >= 2^(k + 1), Start <= 2^(k-2)时会触发以下情况
    MipLevel += any((RectPixels.zw >> MipLevel) - (RectPixels.xy >> MipLevel) > MaxPixelOffset) ? 1 : 0;

    return MipLevel;
}

float GetMinDepthFromHZB(/*float2 HZBSize, */uint4 SamplePosition, uint HZBLevel, Texture2D<float> HZBTexture, SamplerState HZBSampler)
{
    //#TODO: GatherLODRed
    float4 Depth;
    Depth.x = HZBTexture.Load(uint3(SamplePosition.x, SamplePosition.w, HZBLevel)); // (-,+)
    Depth.y = HZBTexture.Load(uint3(SamplePosition.z, SamplePosition.w, HZBLevel)); // (+,+)
    Depth.z = HZBTexture.Load(uint3(SamplePosition.z, SamplePosition.y, HZBLevel)); // (+,-)
    Depth.w = HZBTexture.Load(uint3(SamplePosition.x, SamplePosition.y, HZBLevel)); // (-,-)
    
    //Depth.yz = (SamplePosition.x == SamplePosition.z) ? 1.0f : Depth.yz; // Mask off right pixels, if footprint is only one pixel wide.
    //Depth.xy = (SamplePosition.y == SamplePosition.w) ? 1.0f : Depth.xy; // Mask off bottom pixels, if footprint is only one pixel tall.
    
    float2 Depth_0 = min(Depth.xy, Depth.zw);
    float MinDepth = min(Depth_0.x, Depth_0.y);
    return MinDepth;
}

int4 GetScreenRect(int4 ViewRect, float4 NDCRect)
{
    // Map from NDC [-1,1] to target 'texture UV' [0,1] space, X[-1,1] -> [0,1], Y[-1,1] -> [1, 0]
	// CF DX11.3 Functional Spec 3.3.1 Pixel Coordinate System
    float4 RectUV = saturate(NDCRect * float2(0.5f, -0.5f).xyxy + 0.5f).xwzy;
    
	// Calculate pixel footprint of rectangle in full resolution.
	// To make the bounds as tight as possible we only consider a pixel part of the footprint when its pixel center is covered by the rectangle.
	// Only when the pixel center is covered can that pixel be rasterized by anything inside the rectangle.
	// Using pixel centers instead of conservative floor/ceil bounds of pixel seems to typically result in ~5% fewer clusters being drawn.
	// NOTE: This assumes anything inside RectMin/RectMax gets rasterized with one centered sample. This will have to be adjusted for conservative rasterization, MSAA or similar features.
    float2 ViewSize = ViewRect.zw - ViewRect.xy;
    
    //Nanite这里是将RectMax偏移半个像素, RectMin偏移半个像素, 若大于等于则代表覆盖, 与寒霜不同的是额外偏移后用来检查Size是否超过半个像素来判断是否应该光栅
    //因为我们主要是需要屏幕空间的Rect信息, 所以使用Nanite算法
    //这个算法如果Bound与起始位置刚好相交, 不会光栅起始三角形, 若起始位置不相加
    int4 Pixels = int4(RectUV * ViewSize.xyxy + ViewRect.xyxy + float4(0.5f, 0.5f, -0.5f, -0.5f));
    //int4 Pixels = int4(RectUV * ViewSize.xyxy + ViewRect.xyxy + float4(0.f, 0.f, -0.5f, -0.5f)); 
    
    //Clamp不会影响越界情况, 依然能够正常判断, 因为起始值并没有被Clamp只是判断了最小值
    Pixels.xy = max(Pixels.xy, ViewRect.xy);
    Pixels.zw = min(Pixels.zw, ViewRect.zw - 1);
    
    return Pixels;
}